import { CharStream, CommonTokenStream, InputStream, Token } from "antlr4";
import Java20Lexer from "../../Lexer_And_Parser/For_Java/Java20Lexer.js";
import Java20Parser from "../../Lexer_And_Parser/For_Java/Java20Parser.js";

// Helper Function to use JAVA20LEXER to get tokens in a readable format from a Java source code
export const getTokensFromJavaSrcCode = (src_code) => {
  // converting src code to input stream
  const inputStream = new InputStream(src_code);

  const lexer = new Java20Lexer(inputStream);
  const tokenStream = new CommonTokenStream(lexer);
  tokenStream.fill();

  const finalTokens = tokenStream.tokens;

  // converting tokens to a more readable format { type, text, line }
  const TokensObjectArray = finalTokens.map((token) => ({
    type: Java20Lexer.symbolicNames[token.type],
    text: token.text,
    line: token.line,
  }));

  return TokensObjectArray;
};

// Helper Function to use JAVA20PARSER to get the JSON parse tree(Concrete Syntax Tree) from a Java source code
export const getCSTFromJavaSrcCode = (src_code) => {
  // helper funtion to generate JSON parse tree from the parse tree generated by the parser
  function parseTreeToJson(node, parser) {
    if (!node) return null;

    if (node.children) {
      return {
        name: parser.ruleNames[node.ruleIndex] || "UNKNOWN",
        children: node.children.map((child) => parseTreeToJson(child, parser)),
      };
    } else {
      return { name: node.getText() };
    }
  }

  // converting src code to input stream
  const inputStream = new InputStream(src_code);
  const lexer = new Java20Lexer(inputStream);
  const tokenStream = new CommonTokenStream(lexer);

  const parser = new Java20Parser(tokenStream);
  parser.buildParseTrees = true;
  // Parse the input stream and get the parse tree
  const tree = parser.compilationUnit();

  // Convert the parse tree to JSON format
  const jsonTree = parseTreeToJson(tree, parser);
  return jsonTree;
};
